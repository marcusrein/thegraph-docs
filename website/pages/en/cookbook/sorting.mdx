---
title: GraphQL Sorting Strategies
---

## Sort by IDs

When creating subgraphs in The Graph, it's important to consider the type of ID used for your entities. This choice can have a significant impact on the performance and ease of use of your subgraph.

If accurate sorting is desired, both Strings and Bytes for IDs are not optimal as the sorting is done non-sequentially which can lead to unexpected results. If attempting to sort by id of type "ID" (which is a string), the ordered sequence might look like this:

schema.graphql:

```graphql
type Transfer @entity {
  id: ID!
  from: Bytes! # address
  to: Bytes! # address
  tokenId: BigInt! # uint256
}
```

Query:

```graphql
{
  transfers(first: 5, orderBy: id) {
    id
    tokenId
  }
}
```

Query Response:

```json
{
  "data": {
    "transfers": [
      {
        "id": "1",
        "tokenId": "1"
      },
      {
        "id": "10",
        "tokenId": "10"
      },
      {
        "id": "100",
        "tokenId": "100"
      },
      {
        "id": "101",
        "tokenId": "101"
      },
      {
        "id": "102",
        "tokenId": "102"
      }
    ]
  }
}
```

If attempting to sort you IDs that are Bytes, the ordered sequence might look like this:

schema.graphql:

```graphql
type Transfer @entity {
  id: Bytes!
  from: Bytes! # address
  to: Bytes! # address
  tokenId: BigInt! # uint256
}
```

Query:

```graphql
{
  transfers(first: 5, orderBy: id) {
    id
    tokenId
  }
}
```

Query Response:

```json
{
  "data": {
    "transfers": [
      {
        "id": "0x00010000",
        "tokenId": "256"
      },
      {
        "id": "0x00020000",
        "tokenId": "512"
      },
      {
        "id": "0x01000000",
        "tokenId": "1"
      },
      {
        "id": "0x01010000",
        "tokenId": "257"
      },
      {
        "id": "0x01020000",
        "tokenId": "513"
      }
    ]
  }
}
```

## Ideal Sorting Strategy of IDs

To improve the sorting, creating another property on the entity that is a BigInt (in this example it is tokenId) will allow for sorting to be optimized sequentially.

```graphql
type Transfer @entity {
  id: Bytes!
  from: Bytes! # address
  to: Bytes! # address
  tokenId: BigInt! # uint256
}
```

Query:

```graphql
{
  transfers(first: 5, orderBy: tokenId) {
    id
    tokenId
  }
}
```

Query Response:

```json
{
  "data": {
    "transfers": [
      {
        "id": "1",
        "tokenId": "1"
      },
      {
        "id": "2",
        "tokenId": "2"
      },
      {
        "id": "3",
        "tokenId": "3"
      },
      {
        "id": "4",
        "tokenId": "4"
      },
      {
        "id": "5",
        "tokenId": "5"
      }
    ]
  }
}
```
